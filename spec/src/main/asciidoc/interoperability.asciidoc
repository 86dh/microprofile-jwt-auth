//
// Copyright (c) 2016-2017 Eclipse Microprofile Contributors:
// Red Hat, IBM
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

## Recommendations for Interoperability

The maximum utility of the MicroProfile JWT(MP-JWT) as a token format depends on the agreement between both identity
providers and service providers. This means identity providers - responsible for issuing tokens - should be able to
issue tokens using the MP-JWT format in a way that service providers can understand in order to introspect the token and
gather information about a subject. To that end, the requirements for the MicroProfile JWT are:

1. Be usable as an authentication token.
2. Be usable as an authorization token that contains Java EE application level roles indirectly granted via a groups claim.
3. Can be mapped to IdentityStore in JSR375.
4. Can support additional standard claims described in https://www.iana.org/assignments/jwt/jwt.xhtml as
well as non-standard claims.

To meet those requirements, we introduce 2 new claims to the MP-JWT:

* "upn": A human readable claim that uniquely identifies the subject or user principal of the token, across
the MicroProfile services the token will be accessed with.
* "groups": The token subject's group memberships that will be mapped to Java EE style application
level roles in the MicroProfile service container.

### Minimum MMP-JWT Required Claims
The required minimum set of MP-JWT claims is then:

typ:: This JOSE header parameter identifies the token as an RFC7519 and must be "JWT" https://tools.ietf.org/html/rfc7519#section-5.1[RFC7519, Section 5.1]
alg:: This JOSE header parameter identifies the cryptographic algorithm used to secure the JWT. MP-JWT requires the
 use of the RSASSA-PKCS1-v1_5 SHA-256 algorithm and must be specified as "RS256", https://tools.ietf.org/html/rfc7515#section-4.1.1[RFC7515, Section 4.1.1]
kid:: This JOSE header parameter is a hint indicating which key was used to secure the JWT. https://tools.ietf.org/html/rfc7515#section-4.1.4[RFC7515, Section-4.1.4]
iss:: The MP-JWT issuer. https://tools.ietf.org/html/rfc7519#section-4.1.1[RFC7519, Section 4.1.1]
sub:: Identifies the principal that is the subject of the JWT. See the "upn" claim for how this relates to the container
 java.security.Principal. https://tools.ietf.org/html/rfc7519#section-4.1.2[RFC7519, Section 4.1.2]
aud:: Identifies the recipients that the JWT is intended for. https://tools.ietf.org/html/rfc7519#section-4.1.3[RFC7519, Section 4.1.3]
exp:: Identifies the expiration time on or after which the JWT MUST NOT be accepted for processing.  The processing of the
    "exp" claim requires that the current date/time MUST be before the expiration date/time listed in the "exp" claim.
    Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.
    Its value MUST be a number containing a NumericDate value. https://tools.ietf.org/html/rfc7519#section-4.1.4[RFC7519, Section 4.1.4]
iat:: Identifies the time at which the JWT was issued.  This claim can be used to determine the age of the JWT.  Its
    value MUST be a number containing a NumericDate value. https://tools.ietf.org/html/rfc7519#section-4.1.6[RFC7519, Section 4.1.6]
jti:: Provides a unique identifier for the JWT. The identifier value MUST be assigned in a manner that ensures that
    there is a negligible probability that the same value will be accidentally assigned to a different data object;
    if the application uses multiple issuers, collisions MUST be prevented among values produced by different issuers
    as well.  The "jti" claim can be used to prevent the JWT from being replayed.  The "jti" value is a case-sensitive
    string. https://tools.ietf.org/html/rfc7519#section-4.1.7[RFC7519, Section 4.1.7]
upn:: This MP-JWT custom claim is the user principal name in the java.security.Principal interface, and is the caller
    principal name in javax.security.enterprise.identitystore.IdentityStore. If this claim is missing, fallback to
    the http://openid.net/specs/openid-connect-core-1_0.html#StandardClaims["preferred_username", OIDC Section 5.1] should be
    attempted, and if that claim is missing, fallback to the "sub" claim should be used.
groups:: This MP-JWT custom claim is the list of group names that have been assigned to the principal of the MP-JWT.
    This typically will required a mapping at the application container level to application deployment roles, but a
    a one-to-one between group names and application role names is required to be performed in addition to any
    other mapping.


[NOTE]
NumericDate used by `exp`, `iat`, and other date related claims is a JSON numeric value
representing the number of seconds from 1970-01-01T00:00:00Z UTC until the specified
UTC date/time, ignoring leap seconds

An example minimal MP-JWT in JSON would be:
```json
{
     "typ": "JWT",
    "alg": "RS256",
    "kid": "abc-1234567890"
}
{
       "iss": "https://server.example.com",
       "aud": "s6BhdRkqt3",
       "jti": "a-123",
       "exp": 1311281970,
       "iat": 1311280970,
       "sub": "24400320",
       "upn": "jdoe@server.example.com",
       "groups": ["red-group", "green-group", "admin-group", "admin"],
}
```
This specification defines a JsonWebToken java.security.Principal interface extension that makes
this set of required claims available via get style accessors. The JsonWebToken interface definition is:

```java
package org.eclipse.microprofile.jwt;
public interface JsonWebToken extends Principal {

    /**
     * Returns the unique name of this principal. This either comes from the upn
     * claim, or if that is missing, the preferred_username claim. Note that for
     * guaranteed interoperability a upn claim should be used.
     *
     * @return the unique name of this principal.
     */
    @Override
    String getName();

    /**
     * Get the raw bearer token string originally passed in the authentication
     * header
     * @return raw bear token string
     */
    default String getRawToken() {
        return getClaim(Claims.raw_token.name());
    }

    /**
     * The iss(Issuer) claim identifies the principal that issued the JWT
     * @return the iss claim.
     */
    default String getIssuer() {
        return getClaim(Claims.iss.name());
    }

    /**
     * The aud(Audience) claim identifies the recipients that the JWT is
     * intended for.
     * @return the aud claim.
     */
    default Set<String> getAudience() {
        return getClaim(Claims.aud.name());
    }

    /**
     * The sub(Subject) claim identifies the principal that is the subject of
     * the JWT. This is the token issuing
     * IDP subject, not the
     *
     * @return the sub claim.
     */
    default String getSubject() {
        return getClaim(Claims.sub.name());
    }

    /**
     * The jti(JWT ID) claim provides a unique identifier for the JWT.
     The identifier value MUST be assigned in a manner that ensures that
     there is a negligible probability that the same value will be
     accidentally assigned to a different data object; if the application
     uses multiple issuers, collisions MUST be prevented among values
     produced by different issuers as well.  The "jti" claim can be used
     to prevent the JWT from being replayed.
     * @return the jti claim.
     */
    default String getTokenID() {
        return getClaim(Claims.jti.name());
    }

    /**
     * The exp (Expiration time) claim identifies the expiration time on or
     * after which the JWT MUST NOT be accepted
     * for processing in seconds since 1970-01-01T00:00:00Z UTC
     * @return the exp claim.
     */
    default long getExpirationTime() {
        return getClaim(Claims.exp.name());
    }

    /**
     * The iat(Issued at time) claim identifies the time at which the JWT was
     * issued in seconds since 1970-01-01T00:00:00Z UTC
     * @return the iat claim
     */
    default long getIssuedAtTime() {
        return getClaim(Claims.iat.name());
    }

    /**
     * The groups claim provides the group names the JWT principal has been
     * granted.
     *
     * This is a MicroProfile specific claim.
     * @return a possibly empty set of group names.
     */
    default Set<String> getGroups() {
        return getClaim(Claims.groups.name());
    }

    /**
     * Access the names of all claims are associated with this token.
     * @return non-standard claim names in the token
     */
    Set<String> getClaimNames();

    /**
     * Verify is a given claim exists
     * @param claimName - the name of the claim
     * @return true if the JsonWebToken contains the claim, false otherwise
     */
    default boolean containsClaim(String claimName) {
        return claim(claimName).isPresent();
    }

    /**
     * Access the value of the indicated claim.
     * @param claimName - the name of the claim
     * @return the value of the indicated claim if it exists, null otherwise.
     */
    <T> T getClaim(String claimName);

    /**
     * A utility method to access a claim value in an {@linkplain Optional}
     * wrapper
     * @param claimName - the name of the claim
     * @param <T> - the type of the claim value to return
     * @return an Optional wrapper of the claim value
     */
    default <T> Optional<T> claim(String claimName) {
        return Optional.ofNullable(getClaim(claimName));
    }
}
```

### Additional Claims
The JWT can contain any number of other custom and standard claims, and these are
made available from the JsonWebToken getOtherClaim(String) method. An example
MP-JWT that contains additional "auth_time", "preferred_username", "acr",
"nbf" and "roles" claims is:

```json
{
     "typ": "JWT",
    "alg": "RS256",
    "kid": "abc-1234567890"
}
{
   "iss": "https://server.example.com",
   "aud": "s6BhdRkqt3",
   "exp": 1311281970,
   "iat": 1311280970,
   "sub": "24400320",
   "upn": "jdoe@server.example.com",
   "groups: ["red-group", "green-group", "admin-group"],
   "roles": ["auditor", "administrator"],
   "jti": "a-123",
   "auth_time": 1311280969,
   "preferred_username": "jdoe",
   "acr": "phr",
   "nbf":  1311288970
}
```

### The `Claims` Enumeration Utility Class

The `org.eclipse.microprofile.jwt.Claims` utility class encapsulate an enumeration
of all the standard JWT related claims along with a description and the required
Java type for the claim as returned from the `JsonWebToken#getClaim(String)`
method.

```java
public enum Claims {
    // The base set of required claims that MUST have non-null values in the JsonWebToken
    iss("Issuer", String.class),
    sub("Subject", String.class),
    aud("Audience", Set.class),
    exp("Expiration Time", Long.class),
    iat("Issued At Time", Long.class),
    jti("JWT ID", String.class),
    upn("MP-JWT specific unique principal name", String.class),
    groups("MP-JWT specific groups permission grant", Set.class),
    raw_token("MP-JWT specific original bearer token", String.class),

    // The IANA registered, but MP-JWT optional claims
    nbf("Not Before", Long.class),
    auth_time("Time when the authentication occurred", Long.class),
    updated_at("Time the information was last updated", Long.class),
    azp("Authorized party - the party to which the ID Token was issued", String.class),
    nonce("Value used to associate a Client session with an ID Token", String.class),
    at_hash("Access Token hash value", Long.class),
    c_hash("Code hash value", Long.class),

    full_name("Full name", String.class),
    family_name("Surname(s) or last name(s)", String.class),
    middle_name("Middle name(s)", String.class),
    nickname("Casual name", String.class),
    given_name("Given name(s) or first name(s)", String.class),
    preferred_username("Shorthand name by which the End-User wishes to be referred to", String.class),
    email("Preferred e-mail address", String.class),
    email_verified("True if the e-mail address has been verified; otherwise false", Boolean.class),

    gender("Gender", String.class),
    birthdate("Birthday", String.class),
    zoneinfo("Time zone", String.class),
    locale("Locale", String.class),
    phone_number("Preferred telephone number", String.class),
    phone_number_verified("True if the phone number has been verified; otherwise false", Boolean.class),
    address("Preferred postal address", JsonObject.class),
    acr("Authentication Context Class Reference", String.class),
    amr("Authentication Methods References", String.class),
    sub_jwk("Public key used to check the signature of an ID Token", JsonObject.class),
    cnf("Confirmation", String.class),
    sip_from_tag("SIP From tag header field parameter value", String.class),
    sip_date("SIP Date header field value", String.class),
    sip_callid("SIP Call-Id header field value", String.class),
    sip_cseq_num("SIP CSeq numeric header field parameter value", String.class),
    sip_via_branch("SIP Via branch header field parameter value", String.class),
    orig("Originating Identity String", String.class),
    dest("Destination Identity String", String.class),
    mky("Media Key Fingerprint String", String.class),

    jwk("JSON Web Key Representing Public Key", JsonObject.class),
    jwe("Encrypted JSON Web Key", String.class),
    kid("Key identifier", String.class),
    jku("JWK Set URL", String.class),

    UNKNOWN("A catch all for any unknown claim", Object.class)
    ;
...
    /**
     * @return A desccription for the claim
     */
    public String getDescription() {
        return description;
    }

    /**
     * The required type of the claim
     * @return type of the claim
     */
    public Class<?> getType() {
        return type;
    }
}
```

### Service Specific Authorization Claims
An extended form of authorization on a per service basis using a "resource_access"
claim has been postponed to a future release. See <<resource_access,Future Directions>>
for more information.

## Marking a JAX-RS Application as Requiring MP-JWT Access Control
Since the MicroProfile does not specify a deployment format, and currently does
not rely on servlet metadata descriptors, we have added an `org.eclipse.microprofile.jwt.LoginConfig`
annotation that provides the same information as the web.xml login-config
element. It's intended usage is to mark a JAX-RS `Application` as requiring
MicroProfile JWT RBAC as shown in the following sample:

```java
import org.eclipse.microprofile.annotation.LoginConfig;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@LoginConfig(authMethod = "MP-JWT", realmName = "TCK-MP-JWT")
@ApplicationPath("/")
public class TCKApplication extends Application {
}
```

The MicroProfile JWT implementation is responsible for either directly processing
this annotation, or mapping it to an equivalent form of metadata for the
underlying implementation container.

## Mapping MP-JWT Tokens to Java EE Container APIs

The requirements of how a JWT should be exposed via the various Java EE container
APIs is discussed in this section. For the 1.0 release, the only mandatory container
integration is with the JAX-RS container, and injection of the MP-JWT types.

### CDI Injection Requirements

#### Injection of `JsonWebToken`
An MP-JWT implementation must support the injection of the currently authenticated
caller as a JsonWebToken with @RequestScoped scope:

```java
@Path("/endp")
@DenyAll
public class RolesEndpoint {

    @Inject
    private JsonWebToken callerPrincipal;

```

#### Injection of `ClaimValue`

This specification requires support for injection of claims from the current
`JsonWebToken` using the `org.eclipse.microprofile.jwt.Claim` qualifier:

[source,java]
----
/**
 * Annotation used to signify an injection point for a {@link ClaimValue} from
 * a {@link JsonWebToken}
 */
@Qualifier
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
public @interface Claim {
    /**
     * The value specifies the id name the claim to inject
     * @return the claim name
     * @see JsonWebToken#getClaim(String)
     */
    String value() default "";

    /**
     * An alternate way of specifying a claim name using the {@linkplain Claims}
     * enum
     * @return the claim enum
     */
    Claims standard() default Claims.UNKNOWN;

}
----

and `org.eclipse.microprofile.jwt.ClaimValue` interface:
[source,java]
----
/**
 * A representation of a claim in a {@link JsonWebToken}
 * @param <T> the expected type of the claim
 */
public interface ClaimValue<T> extends Principal {

    /**
     * Access the name of the claim.
     * @return The name of the claim as seen in the JsonWebToken content
     */
    @Override
    public String getName();

    /**
     * Access the value of the claim.
     * @return the value of the claim.
     */
    public T getValue();
}
----

with @RequestScoped scoping. The following example code fragment illustrates various
examples of injecting different types of claims using a range of generic forms of
the `ClaimValue`:

[source,java]
----
import org.eclipse.microprofile.jwt.Claim;
import org.eclipse.microprofile.jwt.ClaimValue;
import org.eclipse.microprofile.jwt.Claims;

@Path("/endp")
@DenyAll
public class RolesEndpoint {
...

    @Inject // <1>
    @Claim(standard = Claims.raw_token)
    private ClaimValue<String> rawToken;
    @Inject
    @Claim(standard = Claims.iss)
    private ClaimValue<String> issuer;
    @Inject
    @Claim(standard = Claims.jti)
    private ClaimValue<String> jti;
    @Inject // <2>
    @Claim("jti")
    private ClaimValue<Optional<String>> optJTI;
    @Inject
    @Claim("jti")
    private ClaimValue objJTI;
    @Inject // <3>
    @Claim("aud")
    private ClaimValue<Set<String>> aud;
    @Inject
    @Claim("groups")
    private ClaimValue<Set<String>> groups;
    @Inject // <4>
    @Claim(standard=Claims.iat)
    private ClaimValue<Long> issuedAt;
    @Inject
    @Claim("iat")
    private ClaimValue<Long> dupIssuedAt;
    @Inject
    @Claim("sub")
    private ClaimValue<Optional<String>> optSubject;
    @Inject
    @Claim("auth_time")
    private ClaimValue<Optional<Long>> authTime;
    @Inject // <5>
    @Claim("custom-missing")
    private ClaimValue<Optional<Long>> custom;
----
<1> Injection of the raw MP-JWT token string.
<2> Injection of the jti token id as an `Optional<String>` wapper.
<3> Injection of the aud audience claim as a Set<String>. This is the required
type as seen by looking at the Claims.aud enum value's Java type member.
<4> Injection of the issued at time claim using an @Claim that references the
claim name using the Claims.iat enum value.
<5> Injection of a custom claim that does exist will result in an Optional<Long>
value for which isPresent() will return false.

The example shows that one may specify the name of the claim using with a
string or a `Claims` enum value. The string form would allow for specifying non-standard
claims while the `Claims` enum approach guards against typos and mis-spellings.

The `@RequestScoped` requirement does introduce some additional complexity for
a CDI extension as a producer method cannot have the
`javax.enterprise.inject.spi.InjectionPoint` provided as a parameter to allow
for distinguishing type. This requires that the CDI extension collect the `ClaimValue`
injection sites by `@Claim` value and `ClaimValue` type. An example of one way
to accomplish this via dynamic producer methods is shown in this prototype
extension: https://github.com/MicroProfileJWT/microprofile-jwt-auth-wfswarm/blob/master/src/main/java/org/eclipse/microprofile/jwt/wfswarm/cdi/MPJWTExtension.java[MPJWTExtension].

#### Injection of Claim Values using `javax.inject.Provider<?>`
An MP-JWT implementation is required to support injection of the currently
authenticated `JsonWebToken` claim values using the `javax.inject.Provider<?>`
wrapper as the injection site type as shown in this code fragment:

[source,java]
----
@Path("/endp")
@ApplicationScoped
public class RolesEndpoint {
...

    @Inject
    @Claim(standard = Claims.jti)
    private Provider<String> providerJTI;
    @Inject
    @Claim(standard = Claims.iat)
    private Provider<Long> providerIAT;
    @Inject
    @Claim("groups")
    private Provider<Set<String>> providerGroups;
----

### JAX-RS Container API Integration
The behavior of the following JAX-RS security related methods is required for
MP-JWT implementations.

#### `javax.ws.rs.core.SecurityContext.getUserPrincipal()`
The `java.security.Principal` returned from these methods MUST be an instance of `org.eclipse.microprofile.jwt.JsonWebToken`.

#### `javax.ws.rs.core.SecurityContext#isUserInRole(String)`
This method MUST return true for any name that is included in the MP-JWT "groups" claim, as well as for any
role name that has been mapped to a group name in the MP-JWT "group" claim.

### Mapping from `@RolesAllowed`
Any role names used in @RolesAllowed or equivalent security constraint metadata that match role names in either
the MP-JWT "roles" claim, or role names that have been mapped to group names in the MP-JWT "group" claim, MUST result
in an allowing authorization decision wherever the security constraint has been applied.

### Recommendations for Optional Container Integration
This section describes the expected behaviors for Java EE container APIs other than JAX-RS.

#### javax.security.enterprise.identitystore.IdentityStore.getCallerGroups(CredentialValidationResult)
This method should return the set of names found in the "groups" claim in the JWT if it exists, an empty set otherwise.

#### javax.ejb.SessionContext.getCallerPrincipal()
The java.security.Principal returned from this method MUST be an instance of org.eclipse.microprofile.jwt.JsonWebToken.

#### javax.ejb.SessionContext#isCallerInRole(String)
This method MUST return true for any name that is included in the MP-JWT "groups" claim, as well as for any
role name that has been mapped to a group name in the MP-JWT "group" claim.

#### javax.servlet.http.HttpServletRequest.getUserPrincipal()
The java.security.Principal returned from this method MUST be an instance of org.eclipse.microprofile.jwt.JsonWebToken.

#### javax.servlet.http.HttpServletRequest#isUserInRole(String)
This method MUST return true for any name that is included in the MP-JWT "groups" claim, as well as for any
role name that has been mapped to a group name in the MP-JWT "group" claim.

#### javax.security.jacc.PolicyContext.getContext("javax.security.auth.Subject.container")
The javax.security.auth.Subject returned by the PolicyContext.getContext(String key) method with the standard
"javax.security.auth.Subject.container" key, MUST return a Subject that has a `java.security.Principal` of type
`org.eclipse.microprofile.jwt.JsonWebToken` amongst it's set of `Principal`s returned by `getPrincipals()``. Similarly,
`Subject#getPrincipals(JsonWebToken.class)` must return a set with at least one value. This means that following code
snipet must not throw an AssertionError:

```java
    Subject subject = (Subject) PolicyContext.getContext("javax.security.auth.Subject.container");
    Set<? extends Principal> principalSet = subject.getPrincipals(JsonWebToken.class);
    assert principalSet.size() > 0;
```

## Mapping MP-JWT Token to Other Container APIs
For non-Java EE containers that provide access to some form of `java.security.Principal` representation of an authenticated
caller, the caller principal MUST be compatible with the `org.eclipse.microprofile.jwt.JsonWebToken` interface.
